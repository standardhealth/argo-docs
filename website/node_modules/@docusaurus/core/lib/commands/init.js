"use strict";
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const fs_extra_1 = __importDefault(require("fs-extra"));
const inquirer_1 = __importDefault(require("inquirer"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const shelljs_1 = __importDefault(require("shelljs"));
function hasYarn() {
    try {
        child_process_1.execSync('yarnpkg --version', { stdio: 'ignore' });
        return true;
    }
    catch (e) {
        return false;
    }
}
function isValidGitRepoUrl(gitRepoUrl) {
    return ['https://', 'git@'].some(item => gitRepoUrl.startsWith(item));
}
function updatePkg(pkgPath, obj) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield fs_extra_1.default.readFile(pkgPath, 'utf-8');
        const pkg = JSON.parse(content);
        const newPkg = Object.assign(pkg, obj);
        yield fs_extra_1.default.outputFile(pkgPath, JSON.stringify(newPkg, null, 2));
    });
}
function init(rootDir, siteName, reqTemplate) {
    return __awaiter(this, void 0, void 0, function* () {
        const useYarn = hasYarn();
        const templatesDir = path_1.default.resolve(__dirname, '../../templates');
        const templates = fs_extra_1.default
            .readdirSync(templatesDir)
            .filter(d => !d.startsWith('.') && !d.startsWith('README'));
        const gitChoice = 'Git repository';
        const templateChoices = [...templates, gitChoice];
        let name = siteName;
        // Prompt if siteName is not passed from CLI
        if (!name) {
            const answers = yield inquirer_1.default.prompt({
                type: 'input',
                name: 'name',
                message: 'What should we name this site?',
                default: 'website',
            });
            name = answers.name;
        }
        if (!name) {
            throw new Error(chalk_1.default.red('A site name is required'));
        }
        const dest = path_1.default.resolve(rootDir, name);
        if (fs_extra_1.default.existsSync(dest)) {
            throw new Error(`Directory already exists at ${dest} !`);
        }
        let template = reqTemplate;
        // Prompt if template is not provided from CLI
        if (!template) {
            const answers = yield inquirer_1.default.prompt({
                type: 'list',
                name: 'template',
                message: 'Select a template below...',
                choices: templateChoices,
            });
            template = answers.template;
        }
        // If user choose Git repository, we'll prompt for the url
        if (template === gitChoice) {
            const { gitRepoUrl } = yield inquirer_1.default.prompt({
                type: 'input',
                name: 'gitRepoUrl',
                validate: (url) => {
                    if (url && isValidGitRepoUrl(url)) {
                        return true;
                    }
                    return chalk_1.default.red(`Invalid repository URL`);
                },
                message: 'Enter a repository URL from GitHub, BitBucket, GitLab, or any other public repo. \n(e.g: https://github.com/ownerName/repoName.git)',
            });
            template = gitRepoUrl;
        }
        console.log();
        console.log(chalk_1.default.cyan('Creating new Docusaurus project ...'));
        console.log();
        if (template && isValidGitRepoUrl(template)) {
            console.log(`Cloning Git template: ${chalk_1.default.cyan(template)}`);
            if (shelljs_1.default.exec(`git clone --recursive ${template} ${dest}`, { silent: true })
                .code !== 0) {
                throw new Error(chalk_1.default.red(`Cloning Git template: ${template} failed!`));
            }
        }
        else if (template && templates.includes(template)) {
            // Docusaurus templates
            try {
                yield fs_extra_1.default.copy(path_1.default.resolve(templatesDir, template), dest);
            }
            catch (err) {
                console.log(`Copying Docusaurus template: ${chalk_1.default.cyan(template)} failed!`);
                throw err;
            }
        }
        else {
            throw new Error('Invalid template');
        }
        // Update package.json info
        try {
            yield updatePkg(path_1.default.join(dest, 'package.json'), {
                name: lodash_1.default.kebabCase(name),
                version: '0.0.0',
                private: true,
            });
        }
        catch (err) {
            console.log(chalk_1.default.red('Failed to update package.json'));
            throw err;
        }
        // We need to Rename the gitignore file to .gitignore
        if (!fs_extra_1.default.pathExistsSync(path_1.default.join(dest, '.gitignore')) &&
            fs_extra_1.default.pathExistsSync(path_1.default.join(dest, 'gitignore'))) {
            yield fs_extra_1.default.move(path_1.default.join(dest, 'gitignore'), path_1.default.join(dest, '.gitignore'));
        }
        if (fs_extra_1.default.pathExistsSync(path_1.default.join(dest, 'gitignore'))) {
            fs_extra_1.default.removeSync(path_1.default.join(dest, 'gitignore'));
        }
        const pkgManager = useYarn ? 'yarn' : 'npm';
        console.log(`Installing dependencies with: ${chalk_1.default.cyan(pkgManager)}`);
        // we use execSync instead of shell.exec to hide installation output
        try {
            child_process_1.execSync(`cd "${name}" && ${useYarn ? 'yarn' : 'npm install'}`);
        }
        catch (err) {
            console.log(chalk_1.default.red('Installation failed'));
            throw err;
        }
        console.log();
        // Display the most elegant way to cd.
        const cdpath = path_1.default.join(process.cwd(), name) === dest
            ? name
            : path_1.default.relative(process.cwd(), name);
        console.log();
        console.log(`Success! Created ${chalk_1.default.cyan(cdpath)}`);
        console.log('Inside that directory, you can run several commands:');
        console.log();
        console.log(chalk_1.default.cyan(`  ${pkgManager} start`));
        console.log('    Starts the development server.');
        console.log();
        console.log(chalk_1.default.cyan(`  ${pkgManager} ${useYarn ? '' : 'run '}build`));
        console.log('    Bundles the app into static files for production.');
        console.log();
        console.log(chalk_1.default.cyan(`  ${pkgManager} deploy`));
        console.log('    Publish website to GitHub pages.');
        console.log();
        console.log('We suggest that you begin by typing:');
        console.log();
        console.log(chalk_1.default.cyan('  cd'), cdpath);
        console.log(`  ${chalk_1.default.cyan(`${pkgManager} start`)}`);
        console.log();
        console.log('Happy hacking!');
    });
}
exports.init = init;
